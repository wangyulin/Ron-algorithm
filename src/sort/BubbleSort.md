#经典排序算法－冒泡排序

    每一个学过编程语言的程序员，或使用C、Java、Python等等写过冒泡排序的实现，那我回顾的第一个算法就是最简单的冒泡排序。
    
####冒泡排序原理

冒泡排序的原理非常容易理解，以下使用按从小到大的顺序为例来说明：

* 1 从数组第0个元素开始，一直到第N-1个元素进行遍历，将当前第i元素和相邻之后的第i+1元素进行比较，如果[i]>[i+1]为真的话，就交换这两个元素的位置，如此进行到第N-1个元素。这一轮下来便可将该数组的最大元素放在数组末尾。如果将数值最大比喻为最重的元素，便可认为是“沉”到了最底。

* 2 进行第2轮时，便从第0个元素开始，到第(N－1)-1,进行第一步中的处理逻辑，这样可得到一个表达式在第n轮时，比较数组的范围便是从0到(N-1)-(n-1),当n＝N时，进行的其实是第0个元素个第0个元素进行。

这就是简单的冒泡排序的处理逻辑，当然还可对此进行优化，当某一轮便利进行相邻元素比较时，没有出现相邻前一个元素大于后者时，可说明该数组已经升序排列，可推出跳出整个排序循环。

####冒泡排序算法分析

* 1 数据如果在初始状态就是正序的，那在遍历一轮之后即可完成排序。关键字比较次数C和记录移动次数M均到最小值：
 	+	C<sub>min</sub> = n-1
 	+	M<sub>min</sub> = 0
 	> 冒泡排序最好的时间复杂度为O(n)
* 2 数据初始状态如果是反序，要进行n-1趟排序，且每次交换两相邻元素位置需要移动三次来达到。
    + C<sub>max</sub> = n(n-1)/2 = O(n<sup>2</sup>)
	+ M<sub>max</sub> = 3n(n-1)/2 = O(n<sup>2</sup>)
	> 冒泡排序最坏的时间复杂度O(n<sup>2</sup>)
